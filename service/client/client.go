package client

import (
	"bytes"
	"compress/gzip"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha1"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
	"twitter_task/infra/config"

	"go.uber.org/zap"
)

type TwitterClient struct {
}

func NewTwitterClient() *TwitterClient {
	return &TwitterClient{}
}

type AuthTokenInfo struct {
	OAuthToken             string `json:"oauth_token"`
	OAuthTokenSecret       string `json:"oauth_token_secret"`
	OauthCallBackConfirmed string `json:"oauth_callback_confirmed"`
}

type AccessTokenInfo struct {
	OAuthToken       string `json:"oauth_token"`
	OAuthTokenSecret string `json:"oauth_token_secret"`
	UserID           string `json:"user_id"`
	ScreenName       string `json:"screen_name"`
}

type FollowingInfo struct {
	Following bool `json:"following"`
}

type TweetInfo struct {
	ID   string `json:"id"`
	Text string `json:"text"`
}

// GenerateOauthV2AuthorizeURL generate oauthv2 url
func (cli *TwitterClient) GenerateOauthV2AuthorizeURL() (string, error) {
	requestUrl := "https://twitter.com/i/oauth2/authorize"
	response_type := "code"
	conf := config.GetServerConfig()
	client_id := conf.Twitter.ClientID
	redirect_uri := conf.Twitter.CallbackURL
	// TODO: save this in redis for future verification
	state := "random_chars_less_than_500_incase_csrf"
	// TODO: save this in redis for future verification
	code_challenge := "random_secret_key_for_server_verification"
	code_challenge_method := "plain" // code_challenge crypto method pain / S256(sha256)
	// tweet read, users read, follows read and follows write rights
	scope := "tweet.read%20users.read%20follows.read%20follows.write"

	params := map[string]string{
		url.QueryEscape("response_type"):         url.QueryEscape(response_type),
		url.QueryEscape("client_id"):             url.QueryEscape(client_id),
		url.QueryEscape("redirect_uri"):          url.QueryEscape(redirect_uri),
		url.QueryEscape("state"):                 url.QueryEscape(state),
		url.QueryEscape("code_challenge"):        url.QueryEscape(code_challenge),
		url.QueryEscape("code_challenge_method"): url.QueryEscape(code_challenge_method),
		url.QueryEscape("scope"):                 scope,
	}
	requestUrl = requestUrl + "?"

	for k, v := range params {
		requestUrl = requestUrl + k + "=" + v + "&"
	}

	return strings.TrimRight(requestUrl, "&"), nil

}

func (cli *TwitterClient) GetOAuthToken() (authTokenInfo *AuthTokenInfo, err error) {

	requestUrl := "https://api.twitter.com/oauth/request_token"

	conf := config.GetServerConfig()
	oauth_callback := conf.Twitter.CallbackURL
	oauth_consumer_key := conf.Twitter.ApiKey
	// generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := conf.Twitter.AccessToken
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("POST", requestUrl, map[string]string{
		url.QueryEscape("oauth_callback"):         url.QueryEscape(oauth_callback),
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.PathEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
	}, conf.Twitter.ApiSecret, conf.Twitter.AccessSecret)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_callback"):         url.QueryEscape(oauth_callback),
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
	})

	zap.L().Debug("got dst", zap.String("dst", dst))

	req, err := http.NewRequest("POST", requestUrl+"?oauth_callback="+url.QueryEscape(oauth_callback), nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var reader io.ReadCloser
	switch resp.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(resp.Body)
		if err != nil {
			return nil, err
		}
		defer reader.Close()
	default:
		reader = resp.Body
	}
	bytes, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	zap.L().Debug("result", zap.String("result", string(bytes)))
	queries, err := url.ParseQuery(string(bytes))
	if err != nil {
		return nil, err
	}
	return &AuthTokenInfo{
		OAuthToken:             queries.Get("oauth_token"),
		OAuthTokenSecret:       queries.Get("oauth_token_secret"),
		OauthCallBackConfirmed: queries.Get("oauth_callback_confirmed"),
	}, nil
}

// oauth_token=XdiYiwAAAAABo54AAAABiXd4Y9g
// oauth_verifier=DA16a8bL4RoEYSEwoJEacNDUEwyM8aLY
func (cli *TwitterClient) GetAccessToken(oAuthToken string, oAuthVerifier string) (accessTokenInfo *AccessTokenInfo, err error) {

	// oauth_token=7588892-kagSNqWge8gB1WwE3plnFsJHAZVfxWD7Vb57p0b4&
	// oauth_token_secret=PbKfYqSryyeKDWz4ebtY3o5ogNLG11WJuZBc9fQrQo
	// OAuth oauth_consumer_key="KjwDXeeff5Uau2MIkBScp3bhW",oauth_signature_method="HMAC-SHA1",oauth_timestamp="1689928572",oauth_nonce="iizVmT0Rph5",oauth_version="1.0",oauth_signature="fvUVxnxHAdpujdBt4%2BJMa9yc0m0%3D"
	// uOdXSKiZgr2qaUOP+Ro4mfWYjy0=
	requestUrl := "https://api.twitter.com/oauth/access_token"

	conf := config.GetServerConfig()

	oauth_consumer_key := conf.Twitter.ApiKey
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := oAuthToken
	oauth_verifier := oAuthVerifier
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("POST", requestUrl, map[string]string{
		url.QueryEscape("oauth_verifier"):         url.QueryEscape(oauth_verifier),
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
	}, conf.Twitter.ApiSecret, conf.Twitter.AccessToken)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_verifier"):         url.QueryEscape(oauth_verifier),
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
	})

	zap.L().Debug("got dst", zap.String("dst", dst))
	req, err := http.NewRequest("POST", fmt.Sprintf("%s?oauth_token=%s&oauth_verifier=%s", requestUrl, oauth_token, oauth_verifier), nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var reader io.ReadCloser
	switch resp.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(resp.Body)
		if err != nil {
			return nil, err
		}
		defer reader.Close()
	default:
		reader = resp.Body
	}
	bytes, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	// oauth_token=1563945976653422592-FPuZFn8oaCRcoBVtX1wKypk0javaUc
	// oauth_token_secret=1k2Gc5MGQLDmfFyYmcSXDbkTzSb0fVbHoOCaCKpWi4qxn
	// user_id=1563945976653422592
	// screen_name=AKMD
	zap.L().Debug("result", zap.String("result", string(bytes)))
	queries, err := url.ParseQuery(string(bytes))
	if err != nil {
		return nil, err
	}
	if queries.Get("oauth_token") == "" {
		return nil, errors.New(string(bytes))
	}
	return &AccessTokenInfo{
		OAuthToken:       queries.Get("oauth_token"),
		OAuthTokenSecret: queries.Get("oauth_token_secret"),
		UserID:           queries.Get("user_id"),
		ScreenName:       queries.Get("screen_name"),
	}, nil
}

// https://developer.twitter.com/en/docs/twitter-api/users/follows/api-reference/post-users-source_user_id-following
func (cli *TwitterClient) FollowUser(userId string, accessToken string, tokenSecret string, targetUserId string) (followingInfo *FollowingInfo, err error) {
	requestUrl := fmt.Sprintf("https://api.twitter.com/2/users/%s/following", userId)

	conf := config.GetServerConfig()

	oauth_consumer_key := conf.Twitter.ApiKey
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := accessToken
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("POST", requestUrl, map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
		url.QueryEscape("target_user_id"):         url.QueryEscape(targetUserId),
	}, conf.Twitter.ApiSecret, tokenSecret)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
		url.QueryEscape("target_user_id"):         url.QueryEscape(targetUserId),
	})

	zap.L().Debug("got dst", zap.String("dst", dst))
	reqData, _ := json.Marshal(map[string]string{
		"target_user_id": targetUserId,
	})
	req, err := http.NewRequest("POST", requestUrl, bytes.NewBuffer(reqData))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	// TODO: not sure about the result
	/*
		{
			"data": {
				"following": false,
				"pending_follow": true
			}
		}
	*/
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	result := make(map[string]*FollowingInfo)
	if err = json.Unmarshal(bytes, &result); err != nil {
		return nil, err
	}
	if result["data"] != nil {
		return result["data"], nil
	}
	return nil, errors.New("get following info failed")
}

func (cli *TwitterClient) IsFollowUserV2(userId string, accessToken string, tokenSecret string) (followingInfo *FollowingInfo, err error) {
	requestUrl := fmt.Sprintf("https://api.twitter.com/2/users/%s/following", userId)

	conf := config.GetServerConfig()

	oauth_consumer_key := conf.Twitter.ApiKey
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := accessToken
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("GET", requestUrl, map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
	}, conf.Twitter.ApiSecret, tokenSecret)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
	})

	zap.L().Debug("got dst", zap.String("dst", dst))
	req, err := http.NewRequest("GET", requestUrl, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	// TODO: not sure about the result
	/*
		{
			"data": {
				"following": false,
				"pending_follow": true
			}
		}
	*/
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	result := make(map[string]*FollowingInfo)
	if err = json.Unmarshal(bytes, &result); err != nil {
		return nil, err
	}
	if result["data"] != nil {
		return result["data"], nil
	}
	return nil, errors.New("get following info failed")
}

// v1.1 not available now
// "{\"errors\":[{\"message\":\"You currently have access to a subset of Twitter API v2 endpoints and limited v1.1 endpoints (e.g. media post, oauth) only. If you need access to this endpoint, you may need a different access level. You can learn more here: https://developer.twitter.com/en/portal/product\",\"code\":453}]}\n"}
// https://developer.twitter.com/en/docs/twitter-api/v1/accounts-and-users/follow-search-get-users/api-reference/get-friendships-show
func (cli *TwitterClient) IsFollowUser(accessToken string, tokenSecret string, sourceScreenName string, targetScreenName string) (followingInfo *FollowingInfo, err error) {

	requestUrl := "https://api.twitter.com/1.1/friendships/show.json"

	conf := config.GetServerConfig()

	oauth_consumer_key := conf.Twitter.ApiKey
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := accessToken
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("GET", requestUrl, map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
		url.QueryEscape("source_screen_name"):     url.QueryEscape(sourceScreenName),
		url.QueryEscape("target_screen_name"):     url.QueryEscape(targetScreenName),
	}, conf.Twitter.ApiSecret, tokenSecret)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
		url.QueryEscape("source_screen_name"):     url.QueryEscape(sourceScreenName),
		url.QueryEscape("target_screen_name"):     url.QueryEscape(targetScreenName),
	})

	zap.L().Debug("got dst", zap.String("dst", dst))
	req, err := http.NewRequest("GET", fmt.Sprintf("%s?source_screen_name=%s&target_screen_name=%s", requestUrl, url.QueryEscape(sourceScreenName), url.QueryEscape(targetScreenName)), nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	// TODO: not sure about the result
	/*
		{
			"relationship": {
				"source": {
					"id": 783214,
					"id_str": "783214",
					"screen_name": "Twitter",
					"following": true,
					"followed_by": true,
					"live_following": false,
					"following_received": null,
					"following_requested": null,
					"notifications_enabled": null,
					"can_dm": true,
					"blocking": null,
					"blocked_by": null,
					"muting": null,
					"want_retweets": null,
					"all_replies": null,
					"marked_spam": null
				},
				"target": {
					"id": 2244994945,
					"id_str": "2244994945",
					"screen_name": "TwitterDev",
					"following": true,
					"followed_by": true,
					"following_received": null,
					"following_requested": null
				}
			}
		}
	*/
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	zap.L().Debug("got result:", zap.String("result", string(bytes)))
	result := make(map[string]map[string]map[string]interface{})
	if err = json.Unmarshal(bytes, &result); err != nil {
		return nil, err
	}
	if result["relationship"] != nil && result["relationship"]["source"] != nil && result["relationship"]["source"]["following"] != nil {
		if following, ok := result["relationship"]["source"]["following"].(bool); ok {
			return &FollowingInfo{
				Following: following,
			}, nil
		}

	}
	return nil, errors.New("get following info failed")
}

// https://developer.twitter.com/en/docs/twitter-api/tweets/manage-tweets/quick-start
func (cli *TwitterClient) TweetText(accessToken string, tokenSecret string, text string) (*TweetInfo, error) {
	requestUrl := "https://api.twitter.com/2/tweets"
	conf := config.GetServerConfig()

	oauth_consumer_key := conf.Twitter.ApiKey
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := accessToken
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("POST", requestUrl, map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
		url.QueryEscape("text"):                   url.QueryEscape(text),
	}, conf.Twitter.ApiSecret, tokenSecret)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
		url.QueryEscape("text"):                   url.QueryEscape(text),
	})

	zap.L().Debug("got dst", zap.String("dst", dst))
	reqData, _ := json.Marshal(map[string]string{
		"text": text,
	})
	req, err := http.NewRequest("POST", requestUrl, bytes.NewBuffer(reqData))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	// TODO: not sure about the result
	/*
		{
			"data": {
				"id": "1445880548472328192",
				"text": "Hello world!"
			}
		}
	*/
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	result := make(map[string]*TweetInfo)
	if err = json.Unmarshal(bytes, &result); err != nil {
		return nil, err
	}
	if result["data"] != nil {
		return result["data"], nil
	}
	return nil, errors.New("get tweet info failed")
}

func (cli *TwitterClient) IsTweetPost(accessToken string, tokenSecret string, text string) (*TweetInfo, error) {
	requestUrl := "https://api.twitter.com/2/tweets/search/recent" // query=text

	conf := config.GetServerConfig()

	oauth_consumer_key := conf.Twitter.ApiKey
	oauth_nonce := generateNonce()
	oauth_signature_method := "HMAC-SHA1"
	oauth_timestamp := time.Now().Unix()
	oauth_token := accessToken
	oauth_version := "1.0"

	// contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm.
	oauth_signature := generateSignature("GET", requestUrl, map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.PathEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.PathEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.PathEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.PathEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.PathEscape(oauth_version),
		url.QueryEscape("query"):                  url.QueryEscape(text),
	}, conf.Twitter.ApiSecret, tokenSecret)
	zap.L().Debug("got oauth_signature", zap.String("signature", oauth_signature))

	dst := generateDst(map[string]string{
		url.QueryEscape("oauth_consumer_key"):     url.QueryEscape(oauth_consumer_key),
		url.QueryEscape("oauth_nonce"):            url.QueryEscape(oauth_nonce),
		url.QueryEscape("oauth_signature_method"): url.QueryEscape(oauth_signature_method),
		url.QueryEscape("oauth_timestamp"):        url.QueryEscape(strconv.Itoa(int(oauth_timestamp))),
		url.QueryEscape("oauth_token"):            url.QueryEscape(oauth_token),
		url.QueryEscape("oauth_version"):          url.QueryEscape(oauth_version),
		url.QueryEscape("oauth_signature"):        url.QueryEscape(oauth_signature),
		url.QueryEscape("query"):                  url.QueryEscape(text),
	})

	req, err := http.NewRequest("GET", fmt.Sprintf("%s?query=%s", requestUrl, url.QueryEscape(text)), nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", dst)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	// TODO: not sure about the result
	/*
		{
			"data": [
				{
					"id": "1275840243636322304",
					"text": "RT @polarbearrs: Hi  #VisibleWomen ✨ I’m Anna, I’m a Black + Latina Caribbean illustrator based in NYC. I love making dreamy surrealist por…"
				},
				{
					"id": "1275840238498308097",
					"text": "RT @DavidYankovich: A man who admitted his own guilt twice is getting freed from prison while black folks who jump a turnstile in NYC subwa…"
				},
				{
					"id": "1275840234521899008",
					"text": "@freetesla11 @square1_NYC @FakeMikeMiseph @ajn465 @krystalball His evils have actually become bipartisan for the most part. Much like Reagan, in a sense.\nTrump is disorganized and incompetent. He was handed an unprecedented level of power when he got inaugurated(both chambers, courts, governorships) and yet still accomplished very little."
				},
				{
					"id": "1275840231883898880",
					"text": "RT @NotifyNYC: AMBER Alert: Ahsan Ali, 15-year-old  male from 46th Avenue in Queens, in a white Toyota Sienna with license plate number JJX…"
				},
				{
					"id": "1275840228402569216",
					"text": "@BeltwayGreg @zachdcarter you realize Amazon increased its presence in NYC anyway, without any tax incentives, right?"
				},
				{
					"id": "1275840227924414464",
					"text": "RT @mcgoawayylmao: @DeeH_NYC i can't wait for your best picture speech at the oscars"
				},
				{
					"id": "1275840226922057728",
					"text": "@SnottieDrippen It’s like another account tweeted a video saying JR Smith IS a bucket then used footage almost exclusively from his time in Denver and NYC as if it was last season..."
				},
				{
					"id": "1275840226657816579",
					"text": "@tracifrost1976 In NYC we wear masks.   If you're still not sure if they are good for anything, take a look at this graph.  We're keeping it low. https://t.co/pdmt5RG53h"
				},
				{
					"id": "1275840225844113409",
					"text": "@NYCMayor Where is the money you promised NYC public schools families. We were suppose to get it the first week of June"
				},
				{
					"id": "1275840222559899649",
					"text": "Just wondering how the government plans on monitoring out of state visitors. Plenty of people live in Jersey that work in NYC"
				}
			],
			"meta": {
				"newest_id": "1275840243636322304",
				"oldest_id": "1275840222559899649",
				"result_count": 10,
				"next_token": "b26v89c19zqg8o3fo7gesq314yb2ynhwgmfg7az3v76v1"
			}
		}
	*/

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	result := make(map[string][]*TweetInfo)

	if err = json.Unmarshal(bytes, &result); err != nil {
		return nil, err
	}
	if result["data"] != nil && len(result["data"]) > 0 {
		return result["data"][0], nil
	}
	return nil, errors.New("get tweet info failed")
}

func generateNonce() string {
	// Generate 32 bytes of random data.
	randomBytes := make([]byte, 32)
	rand.Read(randomBytes)

	// Convert the random bytes to a string.
	encodedData := base64.StdEncoding.EncodeToString(randomBytes)
	// Strip out all non-word characters.
	nonAlphanumericRegex := regexp.MustCompile(`[^a-zA-Z0-9 ]+`)
	alphanumericString := nonAlphanumericRegex.ReplaceAllString(encodedData, "")
	return alphanumericString
}

func generateSignature(method string, requestUrl string, params map[string]string, apiSecret string, accessSecret string) string {
	keys := make([]string, 0, len(params))
	for k := range params {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var param_string = ""
	for _, key := range keys {
		param_string += key + "="
		param_string += params[key]
		param_string += "&"
	}
	paramLength := len(param_string)
	if param_string[paramLength-1] == '&' {
		param_string = param_string[:paramLength-1]
	}
	signature_string := strings.ToUpper(method) + "&"
	signature_string += url.QueryEscape(requestUrl) + "&"
	signature_string += url.QueryEscape(param_string)
	zap.L().Debug("got signature_string", zap.String("signature_string", signature_string))

	signature_key := url.QueryEscape(apiSecret) + "&" + url.QueryEscape(accessSecret)
	zap.L().Debug("got signature_key", zap.String("signature_key", signature_key))

	// Create an HMAC
	hmac := hmac.New(sha1.New, []byte(signature_key))
	// Update the HMAC with the message
	hmac.Write([]byte(signature_string))
	// Get the hash
	hashSum := hmac.Sum(nil)
	return base64.StdEncoding.EncodeToString(hashSum)
}

func generateDst(params map[string]string) string {
	dst := `OAuth `
	keys := make([]string, 0, len(params))
	for k := range params {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		dst += key + "="
		dst += `"` + params[key] + `",`
	}
	dstLength := len(dst)
	if dst[dstLength-1] == ',' {
		dst = dst[:dstLength-1]
	}
	return dst
}
